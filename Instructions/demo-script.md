# Demonstration Script:


## Make a quick code change to kick off the process

- Go to Code tab of the repository
- Go to src ➡️ components ➡️ home.js
- Edit the file:

      In the function `SelectLanguages(props){..}`, 

    replace 

      `const languages = ['All', 'JavaScript', 'Java', 'CSharp', 'Python', 'Go'];`

    with

      `const languages = ['All', 'JavaScript', 'Java', 'CSharp', 'Python', 'Go', 'Rust'];`

     If `Rust` is already on the list, delete it.

- Commit with:
**Message:** `adding Rust (or removing Rust)`
- Select the option to create a new branch and start a pull request
- you can call the branch anything, `adding-rust` would be a good example
- Create the pull request: You can use the same title `adding Rust (or removing Rust)`. 

https://user-images.githubusercontent.com/5361987/119584925-fee15f80-be0c-11eb-989f-274493821d41.mp4

## Demo Narrative

1. Firstly the **Deploy Site / Build (pull_request)** workflow will execute to build the application.
2. Show the workflow executing
 
      a. Go to the browser tab showing the **Actions** tab of the repository and select the running job (you may need to refresh) - it will have the same name as the title of your pull request (in this demo script assuming `adding Rust`) and should be running the Deploy Site flow
      
     b. Show the visualization as the job starts executing, state that the job will take a branch depending on how things are configured for the workflow
     
     c. Go to the browser tab showing the **Code** tab of the repository and drill down to  .github ➡️ workflows ➡️ deploy.yml
     
      - Scroll down to the **build** job and point out that it just builds the site and container - does not deploy the application
            - Show that we are using the community of actions - here **docker** to do the heavy lifting for us:
               
           - Login to **Container Registry**
           - **Build and push** the container with caching
      - Show the **Deploy Review** Job
           - Show the **environmen**t keyword. This includes: the **name** of the environment (`review-lab`) and the notification that the **url** for looking at the application built in this environment by this specific execution of the workflow will be generated by the `popular-repos-web` step - specifically the `webapp-url` output.

      - Show that we have a dependency (**needs**) on the **build** job. This means this job will not run until the **build** job succeeds.


     d. Go to the browser tab that has the Pull Request view.

      - Note that the **Deploy Site / Build (pull_request)** has executed and the **Deploy Site / Deploy Review (pull_request)**  is executing

      - Click on **Show environments** to demonstrate that the deployment to the review-lab environment is occurring (or is complete) and has been done by this particular execution of the workflow.

      - Go back to the **Actions** tab and show the execution visualizer. Both **Build** and **Deploy Review** should be complete.

      - Back in the Pull Request view (refresh if necessary) show the environments again and click on **View deployment** - display the site in a private/incognito window (See Issues at the top of this document)

      - That will take you to the web page for that particular deployment and describe that users can see the Rust option showing.





## Conclusion/Final Remarks
- We feel this brings the capability to allow for more rich and flexible continuous delivery (CD) workflows for GitHub Actions
- We have a lot of plans to enrich this in future, such as more protection rules for environments.
- Looking for comments and feedback as to how folks take advantage of these new features and what they would like to see in future
- When is this available? GA in the next couple of months as per our public [roadmap](https://github.com/github/roadmap/projects/1): Actions: [Deployment branches Environment protection rule](https://github.com/github/roadmap/issues/164).
